import React, { useMemo, useEffect } from "react";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faChevronDown, faChevronUp } from "@fortawesome/free-solid-svg-icons";

const JsonPreview = ({ questions, isOpen, onToggle }) => {
  // UUID Generator
  const generateUUID = () =>
    "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = (Math.random() * 16) | 0;
      const v = c === "x" ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });

  // Log questions when they change
  useEffect(() => {
    console.log("JsonPreview received questions:", questions.length, "questions");
    // Check if we have any questions with edge_criteria
    const questionsWithCriteria = questions.filter(q => q.edge_criteria);
    if (questionsWithCriteria.length > 0) {
      console.log("Questions with edge criteria:", questionsWithCriteria);
    }
    
    // Force update of formattedJson when questions change
    const newJson = formatJson(questions);
    console.log("JsonPreview updated JSON:", newJson.length, "items");
  }, [questions]);

  // Separate the json formatting function for better debugging
  const formatJson = (questions) => {
    if (!questions || questions.length === 0) {
      console.log("JsonPreview: No questions to format");
      return [];
    }

    const graphUUID = generateUUID();
    const questionMap = {}; // id => UUID
    const nodeMap = {}; // id => UUID
    let edgePkCounter = 2100;
    let criteriaPkCounter = 1800;
    let tagPkCounter = 250;
    let labelPkCounter = 1200;

    // Generate UUIDs
    questions.forEach((q) => {
      questionMap[q.id] = generateUUID();
      nodeMap[q.id] = generateUUID();
    });

    const json = [];

    // Push graph model
    json.push({
      model: "questionnaire.questionnairegraph",
      pk: graphUUID,
      fields: {
        name: "Survey",
        start: nodeMap[questions[0].id],
        end: nodeMap[questions[questions.length - 1].id],
        category: 5,
        status: "active",
        internal_note: "Survey Test",
        variant: "A",
        variant_weighting: "100",
      },
    });

    // Push question model
    questions.forEach((q) => {
      // Add question
      json.push({
        model: "questionnaire.question",
        pk: questionMap[q.id],
        fields: {
          title: q.text || "Untitled",
          subtitle: q.subtitle || null,
          placeholder: q.placeholder || null,
          type: q.type || "text",
          type_params: {
            options: q.options || [],
            exclusive: [],
          },
          required: q.required ?? true,
          auto_next: q.auto_next || false,
          internal_note: q.internal_note || "Generated by builder",
        },
      });

      // Add tags if present
      if (q.tags && q.tags.length > 0) {
        q.tags.forEach(tag => {
          json.push({
            model: "questionnaire.questiontag",
            pk: tagPkCounter++,
            fields: {
              choice: tag,
              question: questionMap[q.id]
            }
          });
        });
      }

      // Add labels if present
      if (q.labels && q.labels.length > 0) {
        q.labels.forEach(label => {
          json.push({
            model: "questionnaire.questionlabel",
            pk: labelPkCounter++,
            fields: {
              choice: label,
              question: questionMap[q.id]
            }
          });
        });
      }
    });

    // Push node model
    questions.forEach((q) => {
      json.push({
        model: "questionnaire.node",
        pk: nodeMap[q.id],
        fields: {
          question: questionMap[q.id],
          sub_graph: null,
          parent_graph: graphUUID,
        },
      });
    });

    // Add edges and criteria
    questions.forEach((q) => {
      const sourceNode = nodeMap[q.id];

      // Handle linear next_question with criteria
      if (q.next_question && nodeMap[q.next_question]) {
        const edgePk = edgePkCounter++;
        
        // Add edge
        json.push({
          model: "questionnaire.edge",
          pk: edgePk,
          fields: {
            start: sourceNode,
            end: nodeMap[q.next_question],
          },
        });

        // Add edge criteria
        if (q.edge_criteria && q.edge_criteria.length > 0) {
          q.edge_criteria.forEach(criterion => {
            json.push({
              model: "questionnaire.edgetriggercriteria",
              pk: criteriaPkCounter++,
              fields: {
                choice: criterion.choice,
                config: criterion.config || {},
                edge: edgePk,
              },
            });
          });
        } else {
          // Default criteria if none specified
          json.push({
            model: "questionnaire.edgetriggercriteria",
            pk: criteriaPkCounter++,
            fields: {
              choice: "Boolean yes",
              config: {},
              edge: edgePk,
            },
          });
        }
      }

      // Handle branching logic with criteria
      if (q.branches) {
        // Yes branch
        if (q.branches.yes && nodeMap[q.branches.yes]) {
          const edgePk = edgePkCounter++;
          json.push({
            model: "questionnaire.edge",
            pk: edgePk,
            fields: {
              start: sourceNode,
              end: nodeMap[q.branches.yes],
            },
          });

          // Add criteria for yes branch
          if (q.branches.criteria && q.branches.criteria.length > 0) {
            const yesCriteria = q.branches.criteria.filter(c => 
              c.choice === "Boolean yes" || 
              !c.choice.toLowerCase().includes("no")
            );
            
            yesCriteria.forEach(criterion => {
              json.push({
                model: "questionnaire.edgetriggercriteria",
                pk: criteriaPkCounter++,
                fields: {
                  choice: criterion.choice,
                  config: criterion.config || {},
                  edge: edgePk,
                },
              });
            });
          } else {
            json.push({
              model: "questionnaire.edgetriggercriteria",
              pk: criteriaPkCounter++,
              fields: {
                choice: "Boolean yes",
                config: {},
                edge: edgePk,
              },
            });
          }
        }

        // No branch
        if (q.branches.no && nodeMap[q.branches.no]) {
          const edgePk = edgePkCounter++;
          json.push({
            model: "questionnaire.edge",
            pk: edgePk,
            fields: {
              start: sourceNode,
              end: nodeMap[q.branches.no],
            },
          });

          // Add criteria for no branch
          if (q.branches.criteria && q.branches.criteria.length > 0) {
            const noCriteria = q.branches.criteria.filter(c => 
              c.choice === "Boolean no" || 
              c.choice.toLowerCase().includes("not")
            );
            
            noCriteria.forEach(criterion => {
              json.push({
                model: "questionnaire.edgetriggercriteria",
                pk: criteriaPkCounter++,
                fields: {
                  choice: criterion.choice,
                  config: criterion.config || {},
                  edge: edgePk,
                },
              });
            });
          } else {
            json.push({
              model: "questionnaire.edgetriggercriteria",
              pk: criteriaPkCounter++,
              fields: {
                choice: "Boolean no",
                config: {},
                edge: edgePk,
              },
            });
          }
        }
      }
    });

    return json;
  };

  // Use the formatting function in formattedJson useMemo
  const formattedJson = useMemo(() => {
    return formatJson(questions);
  }, [questions]);

  const exportJson = () => {
    const blob = new Blob([JSON.stringify(formattedJson, null, 2)], {
      type: "application/json",
    });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "questions.json";
    link.click();
  };

  return (
    <div className="card mb-3">
      <div className="card-header d-flex justify-content-between align-items-center">
        <h5 className="card-title mb-0">JSON Preview</h5>
        <button
          className="btn btn-link p-0"
          onClick={onToggle}
        >
          <FontAwesomeIcon icon={isOpen ? faChevronUp : faChevronDown} />
        </button>
      </div>
      {isOpen && (
        <div className="card-body">
          <pre className="bg-light p-3 rounded" style={{ maxHeight: "400px", overflow: "auto" }}>
            {JSON.stringify(formattedJson, null, 2)}
          </pre>
        </div>
      )}
    </div>
  );
};

export default JsonPreview;
